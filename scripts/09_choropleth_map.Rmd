---
title: "choropleth_map"
author: "Kota Yamamoto"
date: "`r Sys.Date()`"
output: html_document
---

---
title: "Choropleth maps of main variables"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "..")
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  fig.width = 6,
  fig.height = 6
)

library(tidyverse)
library(arrow)
library(sf)
library(classInt)

# デバッグ用：Rmd 内で実際の getwd() を確認
print(getwd())
print(list.files("data/processed"))
```

```{r load data, include=FALSE}
# 分析データ
reg_dt <- read_parquet("../data/processed/adm2_reg_2019_2024.parquet")



# ADM2 シェープ
adm2 <- st_read("../data/raw/IDN_adm2_gaul2015/IDN_adm2_gaul2015.shp") %>%
  mutate(adm2_code = as.integer(ADM2_CODE))
```


```{r make class func, include=FALSE}
# 階級区分を作るヘルパ
# ・値が全て同じ → 1 クラスだけ返す
# ・quantile の breaks が重複する／エラー → 等間隔に切り直す
make_class <- function(x, n = 5, style = "quantile") {
  x_use <- x[is.finite(x) & !is.na(x)]

  # 有効値が全くない
  if (length(x_use) == 0) {
    return(factor(NA_real_))
  }

  ux <- sort(unique(x_use))

  # 全て同じ値しかない場合：1クラスだけ
  if (length(ux) == 1L) {
    lab <- paste0("=", signif(ux[1], 4))
    out <- ifelse(is.na(x), NA, lab)
    return(factor(out, levels = lab, ordered = TRUE))
  }

  # 有効なクラス数はユニーク値数まで
  n_eff <- min(length(ux), n)

  res <- tryCatch(
    {
      ci <- classInt::classIntervals(x_use, n = n_eff, style = style)
      brks <- unique(ci$brks)

      # breaks が 1 つ以下 or ほぼ同じ → エラー扱いして等間隔にフォールバック
      if (length(brks) <= 1L) stop("non-unique breaks")

      cut(x,
          breaks = brks,
          include.lowest = TRUE,
          dig.lab = 5,
          ordered_result = TRUE)
    },
    error = function(e) {
      # 等間隔（"equal"）にフォールバック
      rng <- range(x_use)
      if (rng[1] == rng[2]) {
        lab <- paste0("=", signif(rng[1], 4))
        out <- ifelse(is.na(x), NA, lab)
        return(factor(out, levels = lab, ordered = TRUE))
      }

      brks_eq <- seq(rng[1], rng[2], length.out = n_eff + 1L)

      cut(x,
          breaks = brks_eq,
          include.lowest = TRUE,
          dig.lab = 5,
          ordered_result = TRUE)
    }
  )

  res
}
```

```{r make map func, include=FALSE}
# 地図を描いて保存する関数
plot_save_map <- function(adm2_map, fill_var, title, file_path) {
  p <- ggplot(adm2_map) +
    geom_sf(aes(fill = .data[[fill_var]]), color = NA) +
    scale_fill_brewer(palette = "YlOrRd", na.value = "grey90") +
    labs(fill = title, title = title) +
    theme_void() +
    theme(
      plot.title = element_text(hjust = 0.5)
    )

  dir.create(dirname(file_path), recursive = TRUE, showWarnings = FALSE)
  ggsave(file_path, p, dpi = 300)
  p
}
```

```{r panel 2019, include=FALSE}
panel_2019 <- reg_dt %>%
filter(year == 2019) %>%
select(adm2_code,
ha_alerts,
chirps_mm,
cloud_share,
burned_ha,
defor_rate)
```

```{r join sf to panel 2019 , include=FALSE}
adm2_map_2019 <- adm2 %>%
left_join(panel_2019, by = "adm2_code")
```

```{r make 5 class, include=FALSE}
#各変数の階級（基本は 5 分位、ダメなら等間隔）を作成

adm2_map_2019 <- adm2_map_2019 %>%
mutate(
ha_alerts_cls = make_class(ha_alerts, n = 5, style = "quantile"),
chirps_mm_cls = make_class(chirps_mm, n = 5, style = "quantile"),
cloud_share_cls = make_class(cloud_share, n = 5, style = "quantile"),
burned_ha_cls = make_class(burned_ha, n = 5, style = "quantile"),
defor_rate_cls = make_class(defor_rate, n = 5, style = "quantile")
)
```

#2019
```{r ha_alerts 2019, include=FALSE}
p_ha_2019 <- plot_save_map(
  adm2_map_2019, "ha_alerts_cls",
  "Alerts (ha), 2019",
  "../outputs/figures/choropleth/alerts/map_ha_alerts_2019.png"
)

p_ha_2019
```

```{r chirps 2019, include=FALSE}
p_chirps_2019 <- plot_save_map(
  adm2_map_2019, "chirps_mm_cls",
  "Rainfall (CHIRPS mm), 2019",
  "../outputs/figures/choropleth/chirps/map_chirps_mm_2019.png"
)

p_chirps_2019
```

```{r cloud 2019, include=FALSE}
p_cloud_2019 <- plot_save_map(
  adm2_map_2019, "cloud_share_cls",
  "Cloud share, 2019",
  "../outputs/figures/choropleth/cloud/map_cloud_share_2019.png"
)

p_cloud_2019
```

```{r burned area 2019, include=FALSE}
p_burned_2019 <- plot_save_map(
  adm2_map_2019, "burned_ha_cls",
  "Burned area (ha), 2019",
  "../outputs/figures/choropleth/burned_ha/map_burned_ha_2019.png"
)

p_burned_2019
```

```{r deforestation rate 2019, include=FALSE}
p_defor_2019 <- plot_save_map(
  adm2_map_2019, "defor_rate_cls",
  "Deforestation rate, 2019",
  "../outputs/figures/choropleth/defor/map_defor_rate_2019.png"
)

p_defor_2019
```

#2020-2024
```{r plot 2020 to 2024, include=FALSE}
years_vec <- 2020:2024

for (yy in years_vec) {
panel_y <- reg_dt %>%
filter(year == yy) %>%
select(adm2_code,
ha_alerts,
chirps_mm,
cloud_share,
burned_ha,
defor_rate)

adm2_map_y <- adm2 %>%
left_join(panel_y, by = "adm2_code") %>%
mutate(
ha_alerts_cls = make_class(ha_alerts, n = 5, style = "quantile"),
chirps_mm_cls = make_class(chirps_mm, n = 5, style = "quantile"),
cloud_share_cls = make_class(cloud_share, n = 5, style = "quantile"),
burned_ha_cls = make_class(burned_ha, n = 5, style = "quantile"),
defor_rate_cls = make_class(defor_rate, n = 5, style = "quantile")
)

plot_save_map(
adm2_map_y, "ha_alerts_cls",
paste0("Alerts (ha), ", yy),
paste0("../outputs/figures/choropleth/alerts/map_ha_alerts_", yy, ".png")
)

plot_save_map(
adm2_map_y, "chirps_mm_cls",
paste0("Rainfall (CHIRPS mm), ", yy),
paste0("../outputs/figures/choropleth/chirps/map_chirps_mm_", yy, ".png")
)

plot_save_map(
adm2_map_y, "cloud_share_cls",
paste0("Cloud share, ", yy),
paste0("../outputs/figures/choropleth/cloud/map_cloud_share_", yy, ".png")
)

plot_save_map(
adm2_map_y, "burned_ha_cls",
paste0("Burned area (ha), ", yy),
paste0("../outputs/figures/choropleth/burned_ha/map_burned_ha_", yy, ".png")
)

plot_save_map(
adm2_map_y, "defor_rate_cls",
paste0("Deforestation rate, ", yy),
paste0("../outputs/figures/choropleth/defor/map_defor_rate_", yy, ".png")
)
}
```




