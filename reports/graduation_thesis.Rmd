---
title: "進捗"
author: "Kota Yamamoto"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document:
    latex_engine: xelatex
header-includes:
  - \usepackage{xeCJK}
  - \setCJKmainfont{Hiragino Sans}
---

# 進捗

- データ収集完了
- 回帰分析完了
  - FE OLS (当期)
  - 2SLS (当期)
  - 2SLS (ラグ有り)
  - ダイナミックパネル分析 × 2SLS (ラグ有り)
- 問題点

- 分析を熱帯雨林の伐採が主に行われている自治体に絞る
→先行研究に倣う


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(fixest)
library(arrow)
library(dplyr)

reg_dt <- arrow::read_parquet("../data/processed/adm2_reg_2019_2024.parquet")
```

```{r dyn_data, echo=FALSE}
# adm2×year で並べてラグを作成
reg_dyn <- reg_dt %>%
  arrange(adm2_code, year) %>%
  group_by(adm2_code) %>%
  mutate(
    defor_rate_l1  = dplyr::lag(defor_rate),   # 被説明変数の1期ラグ
    ln_alerts_l1   = dplyr::lag(ln_alerts),    # alerts の1期ラグ
    cloud_share_l1 = dplyr::lag(cloud_share)   # IV の1期ラグ
  ) %>%
  ungroup() %>%
  filter(
    !is.na(defor_rate_l1),
    !is.na(ln_alerts_l1),
    !is.na(cloud_share_l1)
  )
```

```{r dyn_data_nz, echo=FALSE}
reg_dyn_nz <- reg_dyn %>%
  dplyr::filter(
    !is.na(ln_alerts),  # 欠損を除外（不要ならこの行は削ってOK）
    ln_alerts != 0      # ln_alerts が 0 の行を除外
  )
```

- 分析コードは
https://github.com/kkota25/graduation_thesis.git
で公開
- 20251205_progress.htmlは個人フォルダーにあげました


# 研究の目的

目的：インドネシア ADM2(県および市) レベルで構築した Global Forest Watch の integrated deforestation alerts（以下 alerts）が、同じ地域・年の森林減少（forest loss, defor_rate）を抑制するか、検証する



# データ構築と記述統計
- 対象：インドネシア ADM2 × 2019–2024 年

- 元データソース（Google Earth Engine）
  - integrated deforestation alerts（GFW Integrated Alerts）
  - forest loss（Global Forest Change / GFW）
  - 降水量（CHIRPS）
  - 焼失面積（burned area）
  - 雲量（Sentinel-2 Cloud Probability）
  
## ADM2の概観
```{r adm2_map, echo=FALSE, message=FALSE, warning=FALSE}
library(sf)
library(ggplot2)

# シェープファイルの読み込み
adm2 <- st_read("../data/raw/IDN_adm2_gaul2015/IDN_adm2_gaul2015.shp")

# ADM2 の境界を描画
ggplot(adm2) +
  geom_sf(size = 0.1) +
  theme_void() +
  ggtitle("Indonesia ADM2 (GAUL 2015)")
```

## データの整形
Google Earth engine上で ADM2×年単位に集計

↓

ローカルに CSV としてエクスポート

↓

`scripts/02_*.R` から `scripts/08_*.R` で前処理・結合

↓

最終的に`data/processed/adm2_reg_2019_2024.parquet`（ADM2×年のパネル）を作成


## 主な変数

- `defor_rate`：森林減少率（forest loss / 初期森林面積）
- `ln_loss`：森林損失面積（loss_ha）の log1p
- `ln_alerts`：integrated alerts 面積（ha）の log1p
- `cloud_share`：雲天ピクセル比率（年平均）
- `chirps_mm`：年降水量（mm）
- `burned_ha`：焼失面積（ha）


## データ
```{r data, echo=FALSE}
reg_dt <- arrow::read_parquet("../data/processed/adm2_reg_2019_2024.parquet")
```

Burgess et al. (2012)は、分析対象をインドネシア全土ではなく、
「main forest islands」= Sumatra, Kalimantan, Sulawesi, Papua に限定している。Java, Bali, NTB/NTT, Maluku, Riau Islands などは「baseline 期に森林被覆がごくわずか（negligible forest cover）」とし、サンプルから除外している。

## 記述統計量
```{r data summary, echo=FALSE}
summary(reg_dt)
```


## 主要な図

### 森林減少率の空間分布（例：2019 年）
```{r defor spatial distributuon, echo=FALSE, out.width="80%"}
knitr::include_graphics("../outputs/figures/choropleth/defor/map_defor_rate_2019.png")
```

2019 年時点では、特にカリマンタン島とスマトラ島の一部 ADM2 で defor_rate が高く、
ジャワ島では森林減少がほとんど観測されない。

### alertsの空間分布（例：2019 年）

```{r alerts spatial distributuon, echo=FALSE, out.width="80%"}
knitr::include_graphics("../outputs/figures/choropleth/alerts/map_ha_alerts_2024.png")
```

### alerts の分布（例：2019 年）
```{r alerts distributuon, echo=FALSE, out.width="80%"}
knitr::include_graphics("../outputs/figures/hist/hist_ha_alerts.png")
knitr::include_graphics("../outputs/figures/hist/hist_ln_alerts.png")
```



# 分析

## ラグ変数の作成
```{r make_lags, include=FALSE}
library(dplyr)

reg_lag <- reg_dt %>%
  arrange(adm2_code, year) %>%
  group_by(adm2_code) %>%
  mutate(
    ln_alerts_l1   = dplyr::lag(ln_alerts,   n = 1),  # ln_alerts の1期ラグ
    cloud_share_l1 = dplyr::lag(cloud_share, n = 1)  # cloud_share の1期ラグ
  ) %>%
  ungroup() %>%
  filter(!is.na(ln_alerts_l1), !is.na(cloud_share_l1))  # 2019年などラグ欠損を落とす
```

## Baseline OLS
### Model FE OLS
ベースラインの固定効果付き回帰式は次の通り
$$
defor\_rate_{it}
= \beta_1 \ln(alerts_{it}+1)
+ \beta_2 \,chirps\_mm_{it}
+ \beta_3 \,burned\_ha_{it}
+ \alpha_i + \lambda_t + u_{it},
$$

```{r Baseline_OLS, echo=FALSE}
ols_defor <- feols(
  defor_rate ~ ln_alerts + chirps_mm + burned_ha |
    adm2_code + year,
  data    = reg_dt,
  cluster = ~adm2_code
)

summary(ols_defor)
```

### 解釈(Baseline FEOLS)
- ln_alerts：0.000283（p≈0.13）
アラート面積が増えるほど defor_rate は増える方向ですが、統計的に有意でない。
→ 「alerts が多いほど森林減少率が高い」という関係は、はっきりとは確認できない。

- chirps_mm：-0.00000220（p≈0.029）
降水量が多い地域ほど defor_rate が有意に低い。
→ 雨が多いと森林減少が抑えられている（または起きにくい）傾向。

- burned_ha：ほぼ 0（p≈0.99）
焼失面積は、この仕様では defor_rate とほとんど関係が見られない。





## 2SLS 
### first stage Model
$$
\ln(alerts_{it} + 1)
= \beta_1 \,cloud\_share_{it}
+ \beta_2 \,chirps\_mm_{it}
+ \beta_3 \,burned\_ha_{it}
+ \alpha_i + \lambda_t + v_{it}.
$$

### second stage model
$$
defor\_rate_{it}
= \beta_1 \,\widehat{\ln(alerts_{it}+1)}
+ \beta_1 \,chirps\_mm_{it}
+ \beta_1 \,burned\_ha_{it}
+ \alpha_i + \lambda_t + \varepsilon_{it}.
$$


```{r 2SLS first_stage, echo=FALSE}
fs_ln_alerts <- feols(
  ln_alerts ~ cloud_share + chirps_mm + burned_ha |
    adm2_code + year,
  data    = reg_dt,
  cluster = ~adm2_code
)

summary(fs_ln_alerts)
```

### 解釈(2SLS 第一段階)
- ln_alerts：0.000283（p≈0.13）
アラート面積が増えるほど defor_rate は増える方向ですが、統計的に有意でない
→ 「alerts が多いほど森林減少率が高い」という関係は、はっきりとは確認できない

- chirps_mm：-0.00000220（p≈0.029）
降水量が多い地域ほど defor_rate が有意に低い。
→ 雨が多いと森林減少が抑えられている（または起きにくい）傾向。

- burned_ha：ほぼ 0（p≈0.99）
焼失面積は、この仕様では defor_rate とほとんど関係が見られない。


## 2SLS second stage
### second stage model


```{r 2SLS_second_stage, echo=FALSE}
iv_defor <- feols(
  defor_rate ~ chirps_mm + burned_ha |   # 外生のコントロール
    adm2_code + year |                   # 固定効果
    ln_alerts ~ cloud_share,             # 内生 ~ IV
  data    = reg_dt,
  cluster = ~adm2_code
)

summary(iv_defor)

```

### 解釈(2SLS 第ニ段階)
- ln_alerts：0.000283（p≈0.13）
アラート面積が増えるほど defor_rate は増える方向ですが、統計的に有意でない。
→ 「alerts が多いほど森林減少率が高い」という関係は、はっきりとは確認できない。

- chirps_mm：-0.00000220（p≈0.029）
降水量が多い地域ほど defor_rate が有意に低い。
→ 雨が多いと森林減少が抑えられている（または起きにくい）傾向。

- burned_ha：ほぼ 0（p≈0.99）
焼失面積は、この仕様では defor_rate とほとんど関係が見られない。


## 2SLS with a lag
### first stage

$$
\ln(alerts_{i,t-1}+1)
= \beta_1 \,cloud\_share_{i,t-1}
+ \beta_2 \,chirps\_mm_{it}
+ \beta_3 \,burned\_ha_{it}
+ \alpha_i + \lambda_t + v_{it}.
$$

### Second stage

$$
defor\_rate_{it}
= \beta_1 \,\widehat{\ln(alerts_{i,t-1}+1)}
+ \beta_2 \,chirps\_mm_{it}
+ \beta_3 \,burned\_ha_{it}
+ \alpha_i + \lambda_t + \varepsilon_{it}.
$$

```{r 2SLS_first_stage_lag, echo=FALSE}
fs_ln_alerts_l1 <- feols(
  ln_alerts_l1 ~ cloud_share_l1 + chirps_mm + burned_ha |
    adm2_code + year,
  data    = reg_lag,
  cluster = ~adm2_code
)

summary(fs_ln_alerts_l1)
```

### 解釈(2SLS ラグあり 第一段階)
- cloud_share_l1：-2.75（p≈0.00013, t≈-3.88）
  - 雲量の 1 期ラグと ln_alerts の 1 期ラグの負の関係がかなり強くなっている。
  - t²≈15 → F≈15 と、経験則の 10 を上回り「IV としてはだいぶ強い」。
- chirps_mm：0.000066（p≈0.47）
  - ここでは降水量は ln_alerts_l1 と有意な関係を持たない。
- burned_ha：正で p≈0.075（10%有意かどうかギリギリ）
→ ラグを取ることで、cloud_share_l1 は ln_alerts_l1 に対する「強い操作変数」になっている。

### Second stage


```{r 2SLS_second_stage_lag, echo=FALSE}
iv_defor_l1 <- feols(
  defor_rate ~ chirps_mm + burned_ha |      # 外生コントロール（当期）
    adm2_code + year |                      # 固定効果
    ln_alerts_l1 ~ cloud_share_l1,          # 内生 ~ IV（ともに1期ラグ）
  data    = reg_lag,
  cluster = ~adm2_code
)

summary(iv_defor_l1)
```

### 解釈(2SLS ラグあり 第ニ段階)
- fit_ln_alerts_l1：0.00049（p≈0.56）
  - 点推定はごく小さい正の値。p 値 0.56 と大きく、有意ではない。
  - 「前年 alerts が多いほど翌年の defor_rate が変わる」という強い evidence は得られていない。
- chirps_mm：-0.00000215（p≈0.032）
  - ここでは再び有意に負。IV でも「降水量が多い地域ほど defor_rate が低い」という結果は頑健。
- burned_ha：ほぼ 0（p≈0.998）
→ ラグ付き 2SLS では、
　- first stage はかなり強くなったが、second stage の alerts_l1 の係数は依然として有意でない。
　- 「alerts が翌年の deforestation を抑制（または増加）している」という明確な証拠は得られていない。


## ダイナミック・パネル 2SLS

第一段階（first stage）：

$$
\begin{aligned}
\ln(alerts_{i,t-1}+1)
  &= \pi_0
   + \pi_1 \,cloud\_share_{i,t-1}
   + \pi_2 \,defor\_rate_{i,t-1} \\
  &\quad
   + \pi_3 \,chirps\_mm_{it}
   + \pi_4 \,burned\_ha_{it}
   + \alpha_i + \lambda_t + v_{it}.
\end{aligned} 
$$

第二段階（second stage：構造式）：

$$
defor\_rate_{it}
= \beta_0
 + \beta_1 \,\widehat{\ln(alerts_{i,t-1}+1)}
 + \beta_2 \,defor\_rate_{i,t-1} \\
  &\quad
 + \beta_3 \,chirps\_mm_{it}
 + \beta_4 \,burned\_ha_{it}
 + \alpha_i + \lambda_t + \varepsilon_{it}.
$$


```{r dyn_2sls first, echo=FALSE}
dyn_iv <- feols(
  defor_rate ~ defor_rate_l1 + chirps_mm + burned_ha |
    adm2_code + year |
    ln_alerts_l1 ~ cloud_share_l1,
  data    = reg_dyn,
  cluster = ~adm2_code
)

# first stage
summary(dyn_iv, stage = 1)
```

```{r dyn_2sls second, echo=FALSE}
# second stage
summary(dyn_iv, stage = 2)
```






# 技術的な限界
## データの限界
- Assunção et al. (2023)はデータは自治体×月の長期パネルを使用
- 本研究は ADM2×年で 2019–2024 の 6 年のみ。
→時間があれば、ADM2×月or ADM2×週のデータを取得

- Google Earth Engineでは思いデータを出力するのに時間がかかる(時間的制約)

- Alertsのデータは1000mメッシュで取得（当初は10m）


# 今後の改善案
## ラグの導入


## 政策（enforcement）に近い変数を導入する
インドネシアで利用可能な政策・制度の変数が取れるなら、以下のような強化が考えられる

### 現実的に検討できそうな候補
保護区・保全林（protected areas, conservation forest）比率
・ADM2 内の protected area 面積シェア（固定的な cross-section）を計算し、
・これと year を交差させたダミー（high-PA × post-2019）などを入れる。

### どう使うか
コントロール or 交互作用項 として回帰式に入れる(?)


## 集計頻度を上げる

### 月次・四半期集計のメリット
雲量と alerts の「観測タイミング」の連動をより精密に捉えられる。
first stage が強くなる可能性がある（雲の短期ショックが効いてくる）。

### 実務的な課題
今のパイプラインは ADM2×「年」単位で GEE→CSV→parquet を設計しているので、月次にすると
- GEE のコードを ADM2×month 出力に全面書き換え
- R 側の 02_, 03_ スクリプトも全て修正
- データ量・計算負荷も増加

- Burned area, Forest lossは月次で取得済み
- AlertsはGEEのメモリ不足で取得が難しい
- Cloudsのデータセットが年次なので、月次の取得がむずかしい



# 分析地域の選択

```{r fig_evergreen_2019, echo=FALSE, out.width="80%", fig.cap="熱帯常緑広葉樹の被覆率（2019年）"}
knitr::include_graphics("../outputs/figures/choropleth/map_evergreen_share_2019.png")
```


# 自治体の選定
- ステップ1：
「main forest islands」に近い島（例：Sumatra, Kalimantan, Sulawesi, Papua）に限定。
- ステップ2：
forest2000_ha / total_ha が 2–5% 未満の ADM2 を落とす（Assunção の 2％ルールの district 版）。
- ステップ3：
2019–2024 の loss_ha や defor_rate がずっとゼロに近い ADM2 を除外（前線ではない地域を削る）。
- ステップ4（ロバストネス）：
forest2000_ha / total_ha が中央値以上の ADM2 だけのサンプルでも再推定。


## ステップ1

Burgess et al. (2012) says “We focus our analysis on the main forest islands of Indonesia: moving from west to east, these are Sumatra, Kalimantan, Sulawesi and Papua. The remaining islands (Java, Bali, NTB/NTT, Maluku, and the Riau Islands near Singapore), shown in white, have negligible forest cover in our satellite data.”

```{r extract islands, echo=FALSE}
# Burgess (2012) に倣って main forest islands のみ残す
#   - 入力: reg_dyn（summary(reg_dyn) のデータフレーム）
#   - 出力:
#       * drop_adm1: 落とす州
#       * keep_adm1: 残す州
#       * reg_dyn_main_islands: main forest islands のみのデータ


# 1. 落とすべき adm1_name（Java, Bali, Nusa Tenggara, Maluku, Riau Islands）
drop_adm1 <- c(
  # Java 地方
  "Banten",
  "Dki Jakarta",
  "Jawa Barat",
  "Jawa Tengah",
  "Jawa Timur",
  "Daerah Istimewa Yogyakarta",
  
  # Bali + Nusa Tenggara（Lesser Sunda）
  "Bali",
  "Nusatenggara Barat",
  "Nusatenggara Timur",
  
  # Maluku
  "Maluku",
  "Maluku Utara",
  
  # Riau Islands（本土 Riau とは別）
  "Kepulauan-riau"
)

# 2. 実際に残る adm1_name を確認
keep_adm1 <- sort(setdiff(unique(reg_dyn$adm1_name), drop_adm1))

keep_adm1
# 想定される出力:
# [1] "Bangka Belitung"           
# [2] "Bengkulu"                  
# [3] "Gorontalo"                 
# [4] "Jambi"                     
# [5] "Kalimantan Barat"          
# [6] "Kalimantan Selatan"        
# [7] "Kalimantan Tengah"         
# [8] "Kalimantan Timur"          
# [9] "Lampung"                   
# [10] "Nangroe Aceh Darussalam"   
# [11] "Papua"                     
# [12] "Papua Barat"               
# [13] "Riau"                      
# [14] "Sulawesi Barat"            
# [15] "Sulawesi Selatan"          
# [16] "Sulawesi Tengah"           
# [17] "Sulawesi Tenggara"         
# [18] "Sulawesi Utara"            
# [19] "Sumatera Barat"            
# [20] "Sumatera Selatan"          
# [21] "Sumatera Utara"            

# ※ Bangka Belitung は Sumatra 本土ではない島嶼州なので、
#   落としたい場合は drop_adm1 に "Bangka Belitung" を追加して、
#   上の 2 行をもう一度実行してください。

# 3. main forest islands のみを残したデータを作成
reg_dyn_main_islands <- reg_dyn %>%
  filter(!adm1_name %in% drop_adm1)

# チェック用：州ごとの観測数を確認
reg_dyn_main_islands %>%
  count(adm1_name, sort = TRUE)
```

## ステップ2

--------------------------------------------------
Step 2: forest2000_ha / total_ha が 2–5% 未満の ADM2 を落とす
   データ: reg_dyn_main_islands
   - share_forest2000 を作る
   - 閾値 2% と 5% でフィルタしたデータを作成
--------------------------------------------------
 
```{r generate forest rate in 2000}
# 1. 2000年森林率（forest2000_ha / total_ha）を作成 ----------------
reg_dyn_main_islands <- reg_dyn_main_islands %>%
  mutate(
    share_forest2000 = forest2000_ha / total_ha
  )

# summary(reg_dyn_main_islands$share_forest2000)
```

```{r extract municipalities with 2% or more}
# 2. 閾値 2%（0.02）未満の ADM2 を落とす ----------------------------
#   - 「森林率が 2% 以上」の ADM2 だけ残す
reg_dyn_forest02 <- reg_dyn_main_islands %>%
  filter(share_forest2000 >= 0.02)

# チェック：州ごとの観測数
#reg_dyn_forest02 %>%
#  count(adm1_name, sort = TRUE)
```

```{r extract municipalities with 5% or more}
# 2. 閾値 5%（0.05）未満の ADM2 を落とす ----------------------------
#   - 「森林率が 2% 以上」の ADM2 だけ残す
# reg_dyn_forest05 <- reg_dyn_main_islands %>%
#   filter(share_forest2000 >= 0.05)

# チェック：州ごとの観測数
#reg_dyn_forest05 %>%
#  count(adm1_name, sort = TRUE)
```

## ステップ3
2019–2024（あなたのケース）で deforestation がほぼゼロの ADM2 は、
政策の影響を検出する“フロンティア”とは言い難いので、サンプルから外す

ADM2 ごとに
「loss_ha（森林喪失面積）の平均／最大値」
「defor_rate の平均／最大値」
などを集計し、「常にゼロに近い」ADM2 を除外

```{r frontier des stats}

# Step 3: 2019–2024 の loss_ha / defor_rate が「ほぼゼロ」の ADM2 を除外
#   - 入力: reg_dyn_forest02
#   - 出力:
#       * dyn_frontier_stats : ADM2 ごとの要約
#       * reg_dyn_frontier_loose : 緩めのフロンティア定義
#       * reg_dyn_frontier_strict: 厳しめのフロンティア定義（ロバストネス）



# 0. 念のため、対象期間を明示（reg_dyn は既に 2020–2024 のはずだが）
reg_dyn_forest02 <- reg_dyn_forest02 %>%
  filter(year >= 2019, year <= 2024)

# 1. ADM2 ごとに deforestation の要約統計を計算 --------------------
dyn_frontier_stats <- reg_dyn_forest02 %>%
  group_by(adm2_code, adm1_name, adm2_name) %>%
  summarise(
    n_years        = n(),
    mean_loss_ha   = mean(loss_ha, na.rm = TRUE),
    max_loss_ha    = max(loss_ha,  na.rm = TRUE),
    mean_defor     = mean(defor_rate, na.rm = TRUE),
    max_defor      = max(defor_rate,  na.rm = TRUE),
    .groups = "drop"
  )

# 分布の確認（必要なら）
summary(dyn_frontier_stats$mean_loss_ha)
summary(dyn_frontier_stats$max_loss_ha)
summary(dyn_frontier_stats$mean_defor)
summary(dyn_frontier_stats$max_defor)

```

ほとんど伐採が起きていない ADM2はかなり少ない
閾値を四分位点ベースで決めてフロンティアだけ残す

- 「森林率 ≥ 2%」かつ「deforestation の規模が下位 25% より上の ADM2」を main frontier
- 「森林率 ≥ 2%」かつ「deforestation の規模が中央値より上の ADM2」を strict frontier
として、Assunção / Burgess の「森林のある地域＋実際に deforestation の起きているフロンティア」にかなり近いサンプル設計になります。

```{r select thresolds}
# 1. 四分位点から閾値を計算

q_max_loss  <- quantile(dyn_frontier_stats$max_loss_ha,  probs = c(0.25, 0.5), na.rm = TRUE)
q_max_defor <- quantile(dyn_frontier_stats$max_defor,    probs = c(0.25, 0.5), na.rm = TRUE)

q_max_loss
q_max_defor
```

```{r define frontier}

# 2. フロンティア指標を定義
#    - loose: 1四分位以上の deforestation を経験した ADM2
#    - strict: 中央値以上の deforestation を経験した ADM2

dyn_frontier_stats <- dyn_frontier_stats %>%
  mutate(
    # 緩めの定義（main spec）
    is_frontier_loose = (max_loss_ha >= q_max_loss[1]) |
                        (max_defor   >= q_max_defor[1]),

    # 厳しめの定義（robustness）
    is_frontier_strict = (max_loss_ha >= q_max_loss[2]) |
                         (max_defor   >= q_max_defor[2])
  )

# どれくらい残るか確認
dyn_frontier_stats %>%
  summarise(
    n_total  = n(),
    n_loose  = sum(is_frontier_loose),
    n_strict = sum(is_frontier_strict)
  )
```

```{r generate data with frontier}

# 3. ADM2 フラグを元データ（reg_dyn_forest02）に戻す

reg_dyn_frontier <- reg_dyn_forest02 %>%
  left_join(
    dyn_frontier_stats %>%
      select(adm2_code, is_frontier_loose, is_frontier_strict),
    by = "adm2_code"
  )


# メイン仕様: loose frontier サンプル
reg_dyn_frontier_loose <- reg_dyn_frontier %>%
  filter(is_frontier_loose)

# ロバストネス: strict frontier サンプル
reg_dyn_frontier_strict <- reg_dyn_frontier %>%
  filter(is_frontier_strict)

# チェック
nrow(reg_dyn_forest02)
nrow(reg_dyn_frontier_loose)
nrow(reg_dyn_frontier_strict)

reg_dyn_frontier_loose %>% count(adm1_name, sort = TRUE)
reg_dyn_frontier_strict %>% count(adm1_name, sort = TRUE)
```

## ステップ4

share_forest2000 = forest2000_ha / total_ha の中央値以上の ADM2 だけを使うサンプルを作成

```{r add share_forest2000}


# 1. baseline 森林率 share_forest2000 を reg_dyn_main_islands に作成

reg_dyn_main_islands <- reg_dyn_main_islands %>%
  mutate(
    share_forest2000 = forest2000_ha / total_ha
  )

# baseline 森林率の分布確認（任意）
summary(reg_dyn_main_islands$share_forest2000)
```

```{r get median as thresold}

# 2. 中央値（median）を閾値として計算

med_share_forest2000 <- median(
  reg_dyn_main_islands$share_forest2000,
  na.rm = TRUE
)

med_share_forest2000  # 実際の値を確認しておく

```


```{r robustness sample}

# 3. 中央値以上の ADM2 のみを使うロバストネス・サンプル
#    (a) frontier まで考慮しない純粋な「高森林率サンプル」

reg_dyn_forest_median <- reg_dyn_main_islands %>%
  filter(share_forest2000 >= med_share_forest2000)

# チェック
reg_dyn_forest_median %>%
  count(adm1_name, sort = TRUE)

```

```{r robustness sample with frontier}

# 4. frontier 条件も同時に満たすロバストネス・サンプル
#    - main spec: reg_dyn_frontier_loose の中で median 以上だけ
#    - strict spec: reg_dyn_frontier_strict の中で median 以上だけ


# まず reg_dyn_frontier に baseline 森林率を持たせておく
reg_dyn_frontier <- reg_dyn_frontier %>%
  mutate(
    share_forest2000 = forest2000_ha / total_ha
  )

# (a) main spec (loose frontier + median 以上の森林率)
reg_dyn_frontier_loose_med <- reg_dyn_frontier %>%
  filter(
    is_frontier_loose,
    share_forest2000 >= med_share_forest2000
  )

# (b) strict spec (strict frontier + median 以上の森林率)
reg_dyn_frontier_strict_med <- reg_dyn_frontier %>%
  filter(
    is_frontier_strict,
    share_forest2000 >= med_share_forest2000
  )

# 観測数の確認
nrow(reg_dyn_frontier_loose)
nrow(reg_dyn_frontier_loose_med)

nrow(reg_dyn_frontier_strict)
nrow(reg_dyn_frontier_strict_med)

# 州別の分布も確認
reg_dyn_frontier_loose_med %>%
  count(adm1_name, sort = TRUE)

reg_dyn_frontier_strict_med %>%
  count(adm1_name, sort = TRUE)
```

## data = reg_dyn_frontier_loose
reg_dyn_frontier_loose は、
- main forest islands（Sumatra / Kalimantan / Sulawesi / Papua）のみ
- baseline 森林率 forest2000_ha / total_ha >= 0.02
- 2019–2024 のあいだに「そこそこ deforestation が起きている ADM2」
（max_loss_ha と max_defor がそれぞれ第1四分位以上）
という条件をすべて満たすサンプル


# 2SLS main

```{r 2SLS_first_stage_lag main, echo=FALSE}
fs_ln_alerts_l1 <- feols(
  ln_alerts_l1 ~ cloud_share_l1 + chirps_mm + burned_ha |
    adm2_code + year,
  data = reg_dyn_frontier_loose,
  cluster = ~adm2_code
)

summary(fs_ln_alerts_l1)
```

```{r 2SLS_second_stage_lag main, echo=FALSE}
iv_defor_l1 <- feols(
  defor_rate ~ chirps_mm + burned_ha |      # 外生コントロール（当期）
    adm2_code + year |                      # 固定効果
    ln_alerts_l1 ~ cloud_share_l1,          # 内生 ~ IV（ともに1期ラグ）
  data = reg_dyn_frontier_loose,
  cluster = ~adm2_code
)

summary(iv_defor_l1)
```


# Dynamic 2SLS main

```{r dyn_2sls main first, echo=FALSE}
dyn_iv <- feols(
  defor_rate ~ defor_rate_l1 + chirps_mm + burned_ha |
    adm2_code + year |
    ln_alerts_l1 ~ cloud_share_l1,
  data = reg_dyn_frontier_loose,
  cluster = ~adm2_code
)

# first stage
summary(dyn_iv, stage = 1)
```

```{r dyn_2sls main second, echo=FALSE}
summary(dyn_iv, stage = 2)
```

# Robustness Check
data = reg_dyn_frontier_strict
→ main forest islands ＋ baseline 森林率 ≥ 2% ＋ frontier（厳しめ）のサンプル

data = reg_dyn_frontier_loose_med
→ main forest islands ＋ baseline 森林率 ≥ 2% ＋ frontier（厳しめ）のサンプル

## data = reg_dyn_frontier_strict

```{r 2SLS_first_stage_lag robust 1st, echo=FALSE}
fs_ln_alerts_l1 <- feols(
  ln_alerts_l1 ~ cloud_share_l1 + chirps_mm + burned_ha |
    adm2_code + year,
  data = reg_dyn_frontier_strict,
  cluster = ~adm2_code
)

summary(fs_ln_alerts_l1)
```

```{r 2SLS_second_stage_lag robust 2nd, echo=FALSE}
iv_defor_l1 <- feols(
  defor_rate ~ chirps_mm + burned_ha |      # 外生コントロール（当期）
    adm2_code + year |                      # 固定効果
    ln_alerts_l1 ~ cloud_share_l1,          # 内生 ~ IV（ともに1期ラグ）
  data = reg_dyn_frontier_strict,
  cluster = ~adm2_code
)

summary(iv_defor_l1)
```


```{r dyn_2sls first robust, echo=FALSE}
dyn_iv <- feols(
  defor_rate ~ defor_rate_l1 + chirps_mm + burned_ha |
    adm2_code + year |
    ln_alerts_l1 ~ cloud_share_l1,
  data = reg_dyn_frontier_strict,
  cluster = ~adm2_code
)

# first stage
summary(dyn_iv, stage = 1)
```

```{r dyn_2sls second robust, echo=FALSE}
summary(dyn_iv, stage = 2)
```


## data = reg_dyn_frontier_loose_med

```{r 2SLS_first_stage_lag loose 1st, echo=FALSE}
fs_ln_alerts_l1 <- feols(
  ln_alerts_l1 ~ cloud_share_l1 + chirps_mm + burned_ha |
    adm2_code + year,
  data = reg_dyn_frontier_loose_med,
  cluster = ~adm2_code
)

summary(fs_ln_alerts_l1)
```

```{r 2SLS_second_stage_lag loose 2nd, echo=FALSE}
iv_defor_l1 <- feols(
  defor_rate ~ chirps_mm + burned_ha |      # 外生コントロール（当期）
    adm2_code + year |                      # 固定効果
    ln_alerts_l1 ~ cloud_share_l1,          # 内生 ~ IV（ともに1期ラグ）
  data = reg_dyn_frontier_loose_med,
  cluster = ~adm2_code
)

summary(iv_defor_l1)
```


```{r dyn_2sls first loose 1st, echo=FALSE}
dyn_iv <- feols(
  defor_rate ~ defor_rate_l1 + chirps_mm + burned_ha |
    adm2_code + year |
    ln_alerts_l1 ~ cloud_share_l1,
  data = reg_dyn_frontier_loose_med,
  cluster = ~adm2_code
)

# first stage
summary(dyn_iv, stage = 1)
```

```{r dyn_2sls first loose 2nd, echo=FALSE}
summary(dyn_iv, stage = 2)
```





