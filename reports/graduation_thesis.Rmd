---
title: "進捗"
author: "Kota Yamamoto"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document:
    latex_engine: xelatex
header-includes:
  - \usepackage{xeCJK}
  - \setCJKmainfont{Hiragino Sans}
---

# 進捗

- データ収集完了
- 回帰分析完了
  - FE OLS (当期)
  - 2SLS (当期)
  - 2SLS (ラグ有り)
  - ダイナミックパネル分析 × 2SLS (ラグ有り)
- 問題点

- 分析を熱帯雨林の伐採が主に行われている自治体に絞る
→先行研究に倣う


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(fixest)
library(arrow)
library(dplyr)
library(modelsummary)

reg_dt <- arrow::read_parquet("../data/processed/adm2_reg_2019_2024.parquet")

proj_root <- rprojroot::find_rstudio_root_file()  
out_file  <- file.path(proj_root, "outputs", "tables", "reg_dyn_2sls.tex")
```

```{r dyn_data, echo=FALSE}
# adm2×year で並べてラグを作成
reg_dyn <- reg_dt %>%
  arrange(adm2_code, year) %>%
  group_by(adm2_code) %>%
  mutate(
    defor_rate_l1  = dplyr::lag(defor_rate),   # 被説明変数の1期ラグ
    ln_alerts_l1   = dplyr::lag(ln_alerts),    # alerts の1期ラグ
    cloud_share_l1 = dplyr::lag(cloud_share)   # IV の1期ラグ
  ) %>%
  ungroup() %>%
  filter(
    !is.na(defor_rate_l1),
    !is.na(ln_alerts_l1),
    !is.na(cloud_share_l1)
  )
```

```{r dyn_data_nz, echo=FALSE}
reg_dyn_nz <- reg_dyn %>%
  dplyr::filter(
    !is.na(ln_alerts),  # 欠損を除外（不要ならこの行は削ってOK）
    ln_alerts != 0      # ln_alerts が 0 の行を除外
  )
```

- 分析コードは
https://github.com/kkota25/graduation_thesis.git
で公開
- 20251205_progress.htmlは個人フォルダーにあげました


# 研究の目的

目的：インドネシア ADM2(県および市) レベルで構築した Global Forest Watch の integrated deforestation alerts（以下 alerts）が、同じ地域・年の森林減少（forest loss, defor_rate）を抑制するか、検証する



# データ構築と記述統計
- 対象：インドネシア ADM2 × 2019–2024 年

- 元データソース（Google Earth Engine）
  - integrated deforestation alerts（GFW Integrated Alerts）
  - forest loss（Global Forest Change / GFW）
  - 降水量（CHIRPS）
  - 焼失面積（burned area）
  - 雲量（Sentinel-2 Cloud Probability）
  
## ADM2の概観
```{r adm2_map, echo=FALSE, message=FALSE, warning=FALSE}
library(sf)
library(ggplot2)

# シェープファイルの読み込み
adm2 <- st_read("../data/raw/IDN_adm2_gaul2015/IDN_adm2_gaul2015.shp")

# ADM2 の境界を描画
ggplot(adm2) +
  geom_sf(size = 0.1) +
  theme_void() +
  ggtitle("Indonesia ADM2 (GAUL 2015)")
```

## データの整形
Google Earth engine上で ADM2×年単位に集計

↓

ローカルに CSV としてエクスポート

↓

`scripts/02_*.R` から `scripts/08_*.R` で前処理・結合

↓

最終的に`data/processed/adm2_reg_2019_2024.parquet`（ADM2×年のパネル）を作成


## 主な変数

- `defor_rate`：森林減少率（forest loss / 初期森林面積）
- `ln_loss`：森林損失面積（loss_ha）の log1p
- `ln_alerts`：integrated alerts 面積（ha）の log1p
- `cloud_share`：雲天ピクセル比率（年平均）
- `chirps_mm`：年降水量（mm）
- `burned_ha`：焼失面積（ha）


## データ
```{r data, echo=FALSE}
reg_dt <- arrow::read_parquet("../data/processed/adm2_reg_2019_2024.parquet")
```

Burgess et al. (2012)は、分析対象をインドネシア全土ではなく、
「main forest islands」= Sumatra, Kalimantan, Sulawesi, Papua に限定している。Java, Bali, NTB/NTT, Maluku, Riau Islands などは「baseline 期に森林被覆がごくわずか（negligible forest cover）」とし、サンプルから除外している。

## 記述統計量
```{r data summary, echo=FALSE}
summary(reg_dt)
```

```{r data summary tex, echo=FALSE}
# ---- Table 1: Descriptive statistics (ADM2-year) -> LaTeX (auto fit width) ----
library(dplyr)
library(tidyr)
library(stringr)
library(arrow)
library(knitr)
library(kableExtra)



# 2) 変数セット（必要なら列名を調整）
vars_outcome  <- c("loss_ha", "defor_rate")
vars_treat_iv <- c("ha_alerts", "ln_alerts", "cloud_share")
vars_controls <- c("chirps_mm", "burned_ha", "forest2000_ha")

# 3) 表示ラベル
var_labels <- c(
  loss_ha       = "Forest loss (ha)",
  defor_rate    = "Deforestation rate (loss / forest2000)",
  ha_alerts     = "GFW integrated alerts (ha)",
  ln_alerts     = "ln(alerts ha + 1)",
  cloud_share   = "Cloud share (annual mean)",
  chirps_mm     = "Rainfall (CHIRPS, annual total mm)",
  burned_ha     = "Burned area (ha)",
  forest2000_ha = "Baseline forest endowment (ha, year 2000)"
)

`%||%` <- function(a, b) if (!is.null(a) && !is.na(a) && nzchar(a)) a else b

summarize_var <- function(x, add_alert_extras = FALSE) {
  x_num <- suppressWarnings(as.numeric(x))
  out <- tibble(
    N      = sum(!is.na(x_num)),
    Mean   = mean(x_num, na.rm = TRUE),
    SD     = sd(x_num, na.rm = TRUE),
    Min    = min(x_num, na.rm = TRUE),
    P25    = quantile(x_num, 0.25, na.rm = TRUE, names = FALSE, type = 7),
    Median = quantile(x_num, 0.50, na.rm = TRUE, names = FALSE, type = 7),
    P75    = quantile(x_num, 0.75, na.rm = TRUE, names = FALSE, type = 7),
    Max    = max(x_num, na.rm = TRUE)
  )

  if (add_alert_extras) {
    out <- out %>% mutate(
      `Zero share` = mean(x_num == 0, na.rm = TRUE),
      P90 = quantile(x_num, 0.90, na.rm = TRUE, names = FALSE, type = 7),
      P95 = quantile(x_num, 0.95, na.rm = TRUE, names = FALSE, type = 7),
      P99 = quantile(x_num, 0.99, na.rm = TRUE, names = FALSE, type = 7)
    )
  } else {
    out <- out %>% mutate(`Zero share` = NA_real_, P90 = NA_real_, P95 = NA_real_, P99 = NA_real_)
  }
  out
}

make_panel <- function(reg_dt, var_vec, panel_name) {
  bind_rows(lapply(var_vec, function(v) {
    add_extras <- (v == "ha_alerts")
    summarize_var(reg_dt[[v]], add_alert_extras = add_extras) %>%
      mutate(
        Variable = var_labels[[v]] %||% v,
        panel = panel_name
      )
  }))
}

tab <- bind_rows(
  make_panel(reg_dt, vars_outcome,  "Panel A: Outcomes"),
  make_panel(reg_dt, vars_treat_iv, "Panel B: Treatment and instrument"),
  make_panel(reg_dt, vars_controls, "Panel C: Controls and baseline endowments")
) %>%
  select(panel, Variable, N, Mean, SD, Min, P25, Median, P75, Max, `Zero share`, P90, P95, P99) %>%
  mutate(
    across(c(Mean, SD, Min, P25, Median, P75, Max, P90, P95, P99), ~ round(.x, 3)),
    `Zero share` = round(`Zero share`, 3)
  )

# 4) LaTeX 出力（ここが重要：scale_downで自動的に横幅に収める）
out_path <- "../outputs/tables/table1_descriptive.tex"  # あなたのOverleaf構成に合わせる
dir.create(dirname(out_path), recursive = TRUE, showWarnings = FALSE)

tab_data <- tab %>% select(-panel)

kbl_obj <- tab_data %>%
  knitr::kable(
    format    = "latex",
    booktabs  = TRUE,
    caption   = "Summary statistics (ADM2-year panel).",
    label     = "tab:table1",          # ← \ref{tab:table1} が使える
    align     = "lrrrrrrrrrrrr",
    linesep   = ""
  ) %>%
  kableExtra::kable_styling(
    latex_options = c("hold_position", "scale_down"),  # ← はみ出し対策
    font_size     = 8                                   # 7〜9で調整
  ) %>%
  kableExtra::add_header_above(
    c(" " = 1, "Summary statistics" = 9, "Alerts distribution (only ha\\_alerts)" = 4)
  )

# panel 行を詰める
nA <- length(vars_outcome)
nB <- length(vars_treat_iv)
nC <- length(vars_controls)

kbl_obj <- kbl_obj %>%
  kableExtra::pack_rows("Panel A: Outcomes", 1, nA) %>%
  kableExtra::pack_rows("Panel B: Treatment and instrument", nA + 1, nA + nB) %>%
  kableExtra::pack_rows("Panel C: Controls and baseline endowments", nA + nB + 1, nA + nB + nC)

kableExtra::save_kable(kbl_obj, file = out_path)

out_path


```


## 主要な図

### 森林減少率の空間分布（例：2019 年）
```{r defor spatial distributuon, echo=FALSE, out.width="80%"}
knitr::include_graphics("../outputs/figures/choropleth/defor/map_defor_rate_2019.png")
```

2019 年時点では、特にカリマンタン島とスマトラ島の一部 ADM2 で defor_rate が高く、
ジャワ島では森林減少がほとんど観測されない。

### alertsの空間分布（例：2019 年）

```{r alerts spatial distributuon, echo=FALSE, out.width="80%"}
knitr::include_graphics("../outputs/figures/choropleth/alerts/map_ha_alerts_2024.png")
```

### alerts の分布（例：2019 年）
```{r alerts distributuon, echo=FALSE, out.width="80%"}
knitr::include_graphics("../outputs/figures/hist/hist_ha_alerts.png")
knitr::include_graphics("../outputs/figures/hist/hist_ln_alerts.png")
```



# 分析

## ラグ変数の作成
```{r make_lags, include=FALSE}
library(dplyr)

reg_lag <- reg_dt %>%
  arrange(adm2_code, year) %>%
  group_by(adm2_code) %>%
  mutate(
    ln_alerts_l1   = dplyr::lag(ln_alerts,   n = 1),  # ln_alerts の1期ラグ
    cloud_share_l1 = dplyr::lag(cloud_share, n = 1)  # cloud_share の1期ラグ
  ) %>%
  ungroup() %>%
  filter(!is.na(ln_alerts_l1), !is.na(cloud_share_l1))  # 2019年などラグ欠損を落とす
```

## Baseline OLS
### Model FE OLS
ベースラインの固定効果付き回帰式は次の通り
$$
defor\_rate_{it}
= \beta_1 \ln(alerts_{it}+1)
+ \beta_2 \,chirps\_mm_{it}
+ \beta_3 \,burned\_ha_{it}
+ \alpha_i + \lambda_t + u_{it},
$$

```{r Baseline_FE_OLS, echo=FALSE}
ols_defor <- feols(
  defor_rate ~ ln_alerts + chirps_mm + burned_ha |
    adm2_code + year,
  data    = reg_dt,
  cluster = ~adm2_code
)

out <- "../outputs/tables/table_5_1_baseline_feols.tex"

modelsummary(
  list("FE-OLS (TWFE)" = ols_defor),
  output = out,
  stars  = TRUE,
  statistic = "std.error",
  gof_omit  = "IC|Log|Adj|Within|FE"  # 必要なら調整
)

summary(ols_defor)
```

### 解釈(Baseline FEOLS)
- ln_alerts：0.000283（p≈0.13）
アラート面積が増えるほど defor_rate は増える方向ですが、統計的に有意でない。
→ 「alerts が多いほど森林減少率が高い」という関係は、はっきりとは確認できない。

- chirps_mm：-0.00000220（p≈0.029）
降水量が多い地域ほど defor_rate が有意に低い。
→ 雨が多いと森林減少が抑えられている（または起きにくい）傾向。

- burned_ha：ほぼ 0（p≈0.99）
焼失面積は、この仕様では defor_rate とほとんど関係が見られない。


## 2SLS 
### first stage Model
$$
\ln(alerts_{it} + 1)
= \beta_1 \,cloud\_share_{it}
+ \beta_2 \,chirps\_mm_{it}
+ \beta_3 \,burned\_ha_{it}
+ \alpha_i + \lambda_t + v_{it}.
$$

### second stage model
$$
defor\_rate_{it}
= \beta_1 \,\widehat{\ln(alerts_{it}+1)}
+ \beta_1 \,chirps\_mm_{it}
+ \beta_1 \,burned\_ha_{it}
+ \alpha_i + \lambda_t + \varepsilon_{it}.
$$

### 解釈(2SLS 第一段階)

```{r 2SLS first_stage, echo=FALSE}
fs_ln_alerts <- feols(
  ln_alerts ~ cloud_share + chirps_mm + burned_ha |
    adm2_code + year,
  data    = reg_dt,
  cluster = ~adm2_code
)

summary(fs_ln_alerts)
```

- ln_alerts：0.000283（p≈0.13）
アラート面積が増えるほど defor_rate は増える方向ですが、統計的に有意でない
→ 「alerts が多いほど森林減少率が高い」という関係は、はっきりとは確認できない

- chirps_mm：-0.00000220（p≈0.029）
降水量が多い地域ほど defor_rate が有意に低い。
→ 雨が多いと森林減少が抑えられている（または起きにくい）傾向。

- burned_ha：ほぼ 0（p≈0.99）
焼失面積は、この仕様では defor_rate とほとんど関係が見られない。


### 解釈(2SLS 第2段階)

```{r 2SLS_second_stage, echo=FALSE}
iv_defor <- feols(
  defor_rate ~ chirps_mm + burned_ha |   # 外生のコントロール
    adm2_code + year |                   # 固定効果
    ln_alerts ~ cloud_share,             # 内生 ~ IV
  data    = reg_dt,
  cluster = ~adm2_code
)

summary(iv_defor)

```

- ln_alerts：0.000283（p≈0.13）
アラート面積が増えるほど defor_rate は増える方向ですが、統計的に有意でない。
→ 「alerts が多いほど森林減少率が高い」という関係は、はっきりとは確認できない。

- chirps_mm：-0.00000220（p≈0.029）
降水量が多い地域ほど defor_rate が有意に低い。
→ 雨が多いと森林減少が抑えられている（または起きにくい）傾向。

- burned_ha：ほぼ 0（p≈0.99）
焼失面積は、この仕様では defor_rate とほとんど関係が見られない。

```{r export_table_5_2_nolag, echo=FALSE, message=FALSE, warning=FALSE}

out_nolag <- "../outputs/tables/table_5_2_iv_nolag.tex"

modelsummary(
  list(
    "First stage: ln(alerts+1)"  = fs_ln_alerts,
    "Second stage: defor_rate"   = iv_defor
  ),
  output   = out_nolag,
  stars    = TRUE,
  statistic = "std.error",
  gof_omit = "IC|Log|Adj|Within|FE"
)

# 確認（任意）
file.exists(out_nolag)
```


## 2SLS with a lag
### first stage

$$
\ln(alerts_{i,t-1}+1)
= \beta_1 \,cloud\_share_{i,t-1}
+ \beta_2 \,chirps\_mm_{it}
+ \beta_3 \,burned\_ha_{it}
+ \alpha_i + \lambda_t + v_{it}.
$$

### Second stage

$$
defor\_rate_{it}
= \beta_1 \,\widehat{\ln(alerts_{i,t-1}+1)}
+ \beta_2 \,chirps\_mm_{it}
+ \beta_3 \,burned\_ha_{it}
+ \alpha_i + \lambda_t + \varepsilon_{it}.
$$


### 解釈(2SLS ラグあり 第一段階)

```{r 2SLS_first_stage_lag, echo=FALSE}
fs_ln_alerts_l1 <- feols(
  ln_alerts_l1 ~ cloud_share_l1 + chirps_mm + burned_ha |
    adm2_code + year,
  data    = reg_lag,
  cluster = ~adm2_code
)

summary(fs_ln_alerts_l1)
```

- cloud_share_l1：-2.75（p≈0.00013, t≈-3.88）
  - 雲量の 1 期ラグと ln_alerts の 1 期ラグの負の関係がかなり強くなっている。
  - t²≈15 → F≈15 と、経験則の 10 を上回り「IV としてはだいぶ強い」。
- chirps_mm：0.000066（p≈0.47）
  - ここでは降水量は ln_alerts_l1 と有意な関係を持たない。
- burned_ha：正で p≈0.075（10%有意かどうかギリギリ）
→ ラグを取ることで、cloud_share_l1 は ln_alerts_l1 に対する「強い操作変数」になっている。


### 解釈(2SLS ラグあり 第ニ段階)

```{r 2SLS_second_stage_lag, echo=FALSE}
iv_defor_l1 <- feols(
  defor_rate ~ chirps_mm + burned_ha |      # 外生コントロール（当期）
    adm2_code + year |                      # 固定効果
    ln_alerts_l1 ~ cloud_share_l1,          # 内生 ~ IV（ともに1期ラグ）
  data    = reg_lag,
  cluster = ~adm2_code
)

summary(iv_defor_l1)
```

- fit_ln_alerts_l1：0.00049（p≈0.56）
  - 点推定はごく小さい正の値。p 値 0.56 と大きく、有意ではない。
  - 「前年 alerts が多いほど翌年の defor_rate が変わる」という強い evidence は得られていない。
- chirps_mm：-0.00000215（p≈0.032）
  - ここでは再び有意に負。IV でも「降水量が多い地域ほど defor_rate が低い」という結果は頑健。
- burned_ha：ほぼ 0（p≈0.998）
→ ラグ付き 2SLS では、
　- first stage はかなり強くなったが、second stage の alerts_l1 の係数は依然として有意でない。
　- 「alerts が翌年の deforestation を抑制（または増加）している」という明確な証拠は得られていない。


### 2) ラグあり（preferred）：First stage + Second stage を1枚に出す

```{r export_table_5_2_lag, echo=FALSE, message=FALSE, warning=FALSE}

out_lag <- "../outputs/tables/table_5_2_iv_lag.tex"

modelsummary(
  list(
    "First stage (lag): ln(alerts+1)_{t-1}" = fs_ln_alerts_l1,
    "Second stage (lag): defor_rate_t"      = iv_defor_l1
  ),
  output   = out_lag,
  stars    = TRUE,
  statistic = "std.error",
  gof_omit = "IC|Log|Adj|Within|FE"
)

file.exists(out_lag)
```

## ダイナミック・パネル 2SLS

第一段階（first stage）：

$$
\begin{aligned}
\ln(alerts_{i,t-1}+1)
  &= \pi_0
   + \pi_1 \,cloud\_share_{i,t-1}
   + \pi_2 \,defor\_rate_{i,t-1} \\
  &\quad
   + \pi_3 \,chirps\_mm_{it}
   + \pi_4 \,burned\_ha_{it}
   + \alpha_i + \lambda_t + v_{it}.
\end{aligned} 
$$

第二段階（second stage：構造式）：

$$
defor\_rate_{it}
= \beta_0
 + \beta_1 \,\widehat{\ln(alerts_{i,t-1}+1)}
 + \beta_2 \,defor\_rate_{i,t-1} \\
  &\quad
 + \beta_3 \,chirps\_mm_{it}
 + \beta_4 \,burned\_ha_{it}
 + \alpha_i + \lambda_t + \varepsilon_{it}.
$$


```{r dyn_2sls first, echo=FALSE}
dyn_iv <- feols(
  defor_rate ~ defor_rate_l1 + chirps_mm + burned_ha |
    adm2_code + year |
    ln_alerts_l1 ~ cloud_share_l1,
  data    = reg_dyn,
  cluster = ~adm2_code
)

cat(
  etable(
    summary(dyn_iv, stage = 1:2),  # 1st→2nd の順に並べる
    tex = TRUE,
    # IVの統計量を表に載せたい場合（任意）
    fitstat = ~ . + ivfall + ivwaldall.p
  ),
  sep = "\n"
)

tex_both <- etable(
  summary(dyn_iv, stage = 1:2),
  tex = TRUE,
  fitstat = ~ . + ivfall + ivwaldall.p
)

writeLines(tex_both, "../outputs/tables/dyn_2sls_stages_1_2.tex")

# first stage
summary(dyn_iv, stage = 1)
```

```{r dyn_2sls_second, echo=FALSE}
# second stage
summary(dyn_iv, stage = 2)
```




# 分析地域の選択

```{r fig_evergreen_2019, echo=FALSE, out.width="80%", fig.cap="熱帯常緑広葉樹の被覆率（2019年）"}
knitr::include_graphics("../outputs/figures/choropleth/map_evergreen_share_2019.png")
```


# 自治体の選定
- ステップ1：
「main forest islands」に近い島（例：Sumatra, Kalimantan, Sulawesi, Papua）に限定。

- ステップ2：
forest2000_ha / total_ha が 2–5% 未満の ADM2 を落とす（Assunção の 2％ルールの district 版）。

- ステップ3：
2019–2024 の loss_ha や defor_rate がずっとゼロに近い ADM2 を除外（前線ではない地域を削る）。

- ステップ4（ロバストネス）：
forest2000_ha / total_ha が中央値以上の ADM2 だけのサンプルでも再推定。


## ステップ1

Burgess et al. (2012) says “We focus our analysis on the main forest islands of Indonesia: moving from west to east, these are Sumatra, Kalimantan, Sulawesi and Papua. The remaining islands (Java, Bali, NTB/NTT, Maluku, and the Riau Islands near Singapore), shown in white, have negligible forest cover in our satellite data.”

```{r extract islands, echo=FALSE}
# Burgess (2012) に倣って main forest islands のみ残す
#   - 入力: reg_dyn（summary(reg_dyn) のデータフレーム）
#   - 出力:
#       * drop_adm1: 落とす州
#       * keep_adm1: 残す州
#       * reg_dyn_main_islands: main forest islands のみのデータ


# 1. 落とすべき adm1_name（Java, Bali, Nusa Tenggara, Maluku, Riau Islands）
drop_adm1 <- c(
  # Java 地方
  "Banten",
  "Dki Jakarta",
  "Jawa Barat",
  "Jawa Tengah",
  "Jawa Timur",
  "Daerah Istimewa Yogyakarta",
  
  # Bali + Nusa Tenggara（Lesser Sunda）
  "Bali",
  "Nusatenggara Barat",
  "Nusatenggara Timur",
  
  # Maluku
  "Maluku",
  "Maluku Utara",
  
  # Riau Islands（本土 Riau とは別）
  "Kepulauan-riau"
)

# 2. 実際に残る adm1_name を確認
keep_adm1 <- sort(setdiff(unique(reg_dyn$adm1_name), drop_adm1))

keep_adm1
# 想定される出力:
# [1] "Bangka Belitung"           
# [2] "Bengkulu"                  
# [3] "Gorontalo"                 
# [4] "Jambi"                     
# [5] "Kalimantan Barat"          
# [6] "Kalimantan Selatan"        
# [7] "Kalimantan Tengah"         
# [8] "Kalimantan Timur"          
# [9] "Lampung"                   
# [10] "Nangroe Aceh Darussalam"   
# [11] "Papua"                     
# [12] "Papua Barat"               
# [13] "Riau"                      
# [14] "Sulawesi Barat"            
# [15] "Sulawesi Selatan"          
# [16] "Sulawesi Tengah"           
# [17] "Sulawesi Tenggara"         
# [18] "Sulawesi Utara"            
# [19] "Sumatera Barat"            
# [20] "Sumatera Selatan"          
# [21] "Sumatera Utara"            

# ※ Bangka Belitung は Sumatra 本土ではない島嶼州なので、
#   落としたい場合は drop_adm1 に "Bangka Belitung" を追加して、
#   上の 2 行をもう一度実行してください。

# 3. main forest islands のみを残したデータを作成
reg_dyn_main_islands <- reg_dyn %>%
  filter(!adm1_name %in% drop_adm1)

# チェック用：州ごとの観測数を確認
reg_dyn_main_islands %>%
  count(adm1_name, sort = TRUE)
```

## ステップ2

Step 2: forest2000_ha / total_ha が 2–5% 未満の ADM2 を落とす
   データ: reg_dyn_main_islands
   - share_forest2000 を作る
   - 閾値 2% と 5% でフィルタしたデータを作成
   
森林率が2/ 5%未満の自治体を除外
 
```{r generate forest rate in 2000}
# 1. 2000年森林率（forest2000_ha / total_ha）を作成 ----------------
reg_dyn_main_islands <- reg_dyn_main_islands %>%
  mutate(
    share_forest2000 = forest2000_ha / total_ha
  )

# summary(reg_dyn_main_islands$share_forest2000)
```

```{r extract municipalities with 2% or more}
# 2. 閾値 2%（0.02）未満の ADM2 を落とす ----------------------------
#   - 「森林率が 2% 以上」の ADM2 だけ残す
reg_dyn_forest02 <- reg_dyn_main_islands %>%
  filter(share_forest2000 >= 0.02)

# チェック：州ごとの観測数
#reg_dyn_forest02 %>%
#  count(adm1_name, sort = TRUE)
```

```{r extract municipalities with 5% or more}
# 2. 閾値 5%（0.05）未満の ADM2 を落とす ----------------------------
#   - 「森林率が 2% 以上」の ADM2 だけ残す
# reg_dyn_forest05 <- reg_dyn_main_islands %>%
#   filter(share_forest2000 >= 0.05)

# チェック：州ごとの観測数
#reg_dyn_forest05 %>%
#  count(adm1_name, sort = TRUE)
```

"reg_dyn_forest02": 森林率が2%未満の自治体を除外
"reg_dyn_forest05": 森林率が5%未満の自治体を除外



## ステップ3
2019–2024（あなたのケース）で deforestation がほぼゼロの ADM2 は、
政策の影響を検出する“フロンティア”とは言い難いので、サンプルから外す

ADM2 ごとに
「loss_ha（森林喪失面積）の平均／最大値」
「defor_rate の平均／最大値」
などを集計し、「常にゼロに近い」ADM2 を除外

```{r frontier des stats}

# Step 3: 2019–2024 の loss_ha / defor_rate が「ほぼゼロ」の ADM2 を除外
#   - 入力: reg_dyn_forest02
#   - 出力:
#       * dyn_frontier_stats : ADM2 ごとの要約
#       * reg_dyn_frontier_loose : 緩めのフロンティア定義
#       * reg_dyn_frontier_strict: 厳しめのフロンティア定義（ロバストネス）



# 0. 念のため、対象期間を明示（reg_dyn は既に 2020–2024 のはずだが）
reg_dyn_forest02 <- reg_dyn_forest02 %>%
  filter(year >= 2019, year <= 2024)

# 1. ADM2 ごとに deforestation の要約統計を計算 --------------------
dyn_frontier_stats <- reg_dyn_forest02 %>%
  group_by(adm2_code, adm1_name, adm2_name) %>%
  summarise(
    n_years        = n(),
    mean_loss_ha   = mean(loss_ha, na.rm = TRUE),
    max_loss_ha    = max(loss_ha,  na.rm = TRUE),
    mean_defor     = mean(defor_rate, na.rm = TRUE),
    max_defor      = max(defor_rate,  na.rm = TRUE),
    .groups = "drop"
  )

# 分布の確認（必要なら）
summary(dyn_frontier_stats$mean_loss_ha)
summary(dyn_frontier_stats$max_loss_ha)
summary(dyn_frontier_stats$mean_defor)
summary(dyn_frontier_stats$max_defor)

```

ほとんど伐採が起きていない ADM2はかなり少ない
閾値を四分位点ベースで決めてフロンティアだけ残す

- 「森林率 ≥ 2%」かつ「deforestation の規模が下位 25% より上の ADM2」を main frontier
- 「森林率 ≥ 2%」かつ「deforestation の規模が中央値より上の ADM2」を strict frontier
として、Assunção / Burgess の「森林のある地域＋実際に deforestation の起きているフロンティア」にかなり近いサンプル設計になります。

```{r select thresolds}
# 1. 四分位点から閾値を計算

q_max_loss  <- quantile(dyn_frontier_stats$max_loss_ha,  probs = c(0.25, 0.5), na.rm = TRUE)
q_max_defor <- quantile(dyn_frontier_stats$max_defor,    probs = c(0.25, 0.5), na.rm = TRUE)

q_max_loss
q_max_defor


# q_max_loss[1] は max_loss_ha の25パーセンタイル（下位25%と上位75%の境界）
# q_max_loss[2] は max_loss_ha の中央値（50%点）
# q_max_defor も同様に max_defor の25%点と中央値
```

```{r define frontier}

# 2. フロンティア指標を定義
#    - loose: 1四分位以上の 「最大損失面積が大きい」または「最大損失率が大きい」 を経験した ADM2
#    - strict: 中央値以上の 「最大損失面積が大きい」または「最大損失率が大きい」 を経験した ADM2

dyn_frontier_stats <- dyn_frontier_stats %>%
  mutate(
    # 緩めの定義（main spec）
    is_frontier_loose = (max_loss_ha >= q_max_loss[1]) |
                        (max_defor   >= q_max_defor[1]),

    # 厳しめの定義（robustness）
    is_frontier_strict = (max_loss_ha >= q_max_loss[2]) |
                         (max_defor   >= q_max_defor[2])
  )

# どれくらい残るか確認
dyn_frontier_stats %>%
  summarise(
    n_total  = n(),
    n_loose  = sum(is_frontier_loose),
    n_strict = sum(is_frontier_strict)
  )
```

```{r generate data with frontier}

# 3. ADM2 フラグを元データ（reg_dyn_forest02）に戻す

reg_dyn_frontier <- reg_dyn_forest02 %>%
  left_join(
    dyn_frontier_stats %>%
      select(adm2_code, is_frontier_loose, is_frontier_strict),
    by = "adm2_code"
  )


# メイン仕様: loose frontier サンプル
reg_dyn_frontier_loose <- reg_dyn_frontier %>%
  filter(is_frontier_loose)

# ロバストネス: strict frontier サンプル
reg_dyn_frontier_strict <- reg_dyn_frontier %>%
  filter(is_frontier_strict)

# チェック
nrow(reg_dyn_forest02)
nrow(reg_dyn_frontier_loose)
nrow(reg_dyn_frontier_strict)

reg_dyn_frontier_loose %>% count(adm1_name, sort = TRUE)
reg_dyn_frontier_strict %>% count(adm1_name, sort = TRUE)
```

「森林率 ≥ 2%」かつ

reg_dyn_frontier_loose: 「最大損失面積が大きい」または「最大損失率が大きい」ADM2なら frontier (上位75%)
reg_dyn_frontier_strict: 「最大損失面積が大きい」または「最大損失率が大きい」ADM2なら frontier (上位50%)

reg_dyn_frontier_loose <- reg_dyn_frontier %>%
  filter(is_frontier_loose)
  
reg_dyn_frontier_strict <- reg_dyn_frontier %>%
  filter(is_frontier_strict)
  


## ステップ4

share_forest2000 = forest2000_ha / total_ha の中央値以上の ADM2 だけを使うサンプルを作成

```{r check share_forest2000 dist}
# baseline 森林率の分布確認
summary(reg_dyn_main_islands$share_forest2000)
```

```{r get median as thresold}

# 2. 中央値（median）を閾値として計算

med_share_forest2000 <- median(
  reg_dyn_main_islands$share_forest2000,
  na.rm = TRUE
)

med_share_forest2000  # 実際の値を確認しておく

```


```{r robustness sample}

# 3. 中央値以上の ADM2 のみを使うロバストネス・サンプル
#    (a) frontier まで考慮しない純粋な「高森林率サンプル」

reg_dyn_forest_median <- reg_dyn_main_islands %>%
  filter(share_forest2000 >= med_share_forest2000)

# チェック
reg_dyn_forest_median %>%
  count(adm1_name, sort = TRUE)

```

これで、2000年次の森林率が中央値以上の自治体のみに、はじめのデータを絞れた


```{r robustness sample with frontier}

# 4. frontier 条件も同時に満たすロバストネス・サンプル
#    - main spec: reg_dyn_frontier_loose の中で median 以上だけ
#    - strict spec: reg_dyn_frontier_strict の中で median 以上だけ


# (a) main spec (loose frontier + median 以上の森林率)
reg_dyn_frontier_loose_med <- reg_dyn_frontier %>%
  filter(
    is_frontier_loose,
    share_forest2000 >= med_share_forest2000
  )

# (b) strict spec (strict frontier + median 以上の森林率)
reg_dyn_frontier_strict_med <- reg_dyn_frontier %>%
  filter(
    is_frontier_strict,
    share_forest2000 >= med_share_forest2000
  )

# 観測数の確認
nrow(reg_dyn_frontier_loose)
nrow(reg_dyn_frontier_loose_med)

nrow(reg_dyn_frontier_strict)
nrow(reg_dyn_frontier_strict_med)

# 州別の分布も確認
reg_dyn_frontier_loose_med %>%
  count(adm1_name, sort = TRUE)

reg_dyn_frontier_strict_med %>%
  count(adm1_name, sort = TRUE)
```

reg_dyn_frontier_loose_med <- reg_dyn_frontier %>%
  filter(
    is_frontier_loose,
    share_forest2000 >= med_share_forest2000
  )

reg_dyn_frontier_strict_med <- reg_dyn_frontier %>%
  filter(
    is_frontier_strict,
    share_forest2000 >= med_share_forest2000
  )

## data = reg_dyn_frontier_loose
reg_dyn_frontier_loose は、
- main forest islands（Sumatra / Kalimantan / Sulawesi / Papua）のみ
- baseline 森林率 forest2000_ha / total_ha >= 0.02
- 2019–2024 のあいだに「そこそこ deforestation が起きている ADM2」
（max_loss_ha と max_defor がそれぞれ第1四分位以上）
という条件をすべて満たすサンプル


# 2SLS main

```{r 2SLS_first_stage_lag main, echo=FALSE}
fs_ln_alerts_l1 <- feols(
  ln_alerts_l1 ~ cloud_share_l1 + chirps_mm + burned_ha |
    adm2_code + year,
  data = reg_dyn_frontier_loose,
  cluster = ~adm2_code
)

summary(fs_ln_alerts_l1)
```

```{r 2SLS_second_stage_lag main, echo=FALSE}
iv_defor_l1 <- feols(
  defor_rate ~ chirps_mm + burned_ha |      # 外生コントロール（当期）
    adm2_code + year |                      # 固定効果
    ln_alerts_l1 ~ cloud_share_l1,          # 内生 ~ IV（ともに1期ラグ）
  data = reg_dyn_frontier_loose,
  cluster = ~adm2_code
)

summary(iv_defor_l1)
```


# Dynamic 2SLS main

```{r dyn_2sls main first, echo=FALSE}
dyn_iv <- feols(
  defor_rate ~ defor_rate_l1 + chirps_mm + burned_ha |
    adm2_code + year |
    ln_alerts_l1 ~ cloud_share_l1,
  data = reg_dyn_frontier_loose,
  cluster = ~adm2_code
)

# first stage
summary(dyn_iv, stage = 1)
```

```{r dyn_2sls main second, echo=FALSE}
summary(dyn_iv, stage = 2)
```


# Robustness Check
data = reg_dyn_frontier_strict
→ main forest islands ＋ baseline 森林率 ≥ 2% ＋ frontier（厳しめ）のサンプル

data = reg_dyn_frontier_loose_med
→ main forest islands ＋ baseline 森林率 ≥ 2% ＋ frontier（厳しめ）のサンプル


## data = reg_dyn_frontier_strict
### 2sls strict

```{r 2SLS_first_stage_lag robust 1st, echo=FALSE}
fs_ln_alerts_l1 <- feols(
  ln_alerts_l1 ~ cloud_share_l1 + chirps_mm + burned_ha |
    adm2_code + year,
  data = reg_dyn_frontier_strict,
  cluster = ~adm2_code
)

summary(fs_ln_alerts_l1)
```

```{r 2SLS_second_stage_lag robust 2nd, echo=FALSE}
iv_defor_l1 <- feols(
  defor_rate ~ chirps_mm + burned_ha |      # 外生コントロール（当期）
    adm2_code + year |                      # 固定効果
    ln_alerts_l1 ~ cloud_share_l1,          # 内生 ~ IV（ともに1期ラグ）
  data = reg_dyn_frontier_strict,
  cluster = ~adm2_code
)

summary(iv_defor_l1)
```

### dyn_2sls strict

```{r dyn_2sls first robust, echo=FALSE}
dyn_iv <- feols(
  defor_rate ~ defor_rate_l1 + chirps_mm + burned_ha |
    adm2_code + year |
    ln_alerts_l1 ~ cloud_share_l1,
  data = reg_dyn_frontier_strict,
  cluster = ~adm2_code
)

# first stage
summary(dyn_iv, stage = 1)
```

```{r dyn_2sls second robust, echo=FALSE}
summary(dyn_iv, stage = 2)
```


## data = reg_dyn_frontier_loose_med
### 2sls loose and med cut

```{r 2SLS_first_stage_lag loose 1st, echo=FALSE}
fs_ln_alerts_l1 <- feols(
  ln_alerts_l1 ~ cloud_share_l1 + chirps_mm + burned_ha |
    adm2_code + year,
  data = reg_dyn_frontier_loose_med,
  cluster = ~adm2_code
)

summary(fs_ln_alerts_l1)
```

```{r 2SLS_second_stage_lag loose 2nd, echo=FALSE}
iv_defor_l1 <- feols(
  defor_rate ~ chirps_mm + burned_ha |      # 外生コントロール（当期）
    adm2_code + year |                      # 固定効果
    ln_alerts_l1 ~ cloud_share_l1,          # 内生 ~ IV（ともに1期ラグ）
  data = reg_dyn_frontier_loose_med,
  cluster = ~adm2_code
)

summary(iv_defor_l1)
```

### dyn_2sls loose and med cut

```{r dyn_2sls first loose 1st, echo=FALSE}
dyn_iv <- feols(
  defor_rate ~ defor_rate_l1 + chirps_mm + burned_ha |
    adm2_code + year |
    ln_alerts_l1 ~ cloud_share_l1,
  data = reg_dyn_frontier_loose_med,
  cluster = ~adm2_code
)

# first stage
summary(dyn_iv, stage = 1)
```

```{r dyn_2sls first loose 2nd, echo=FALSE}
summary(dyn_iv, stage = 2)
```


reg_dyn_frontier_loose_med が最もAdj. R2が高い


